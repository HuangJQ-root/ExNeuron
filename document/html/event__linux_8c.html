<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ExNeuron: event_linux.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ExNeuron
   &#160;<span id="projectnumber">2.12</span>
   </div>
   <div id="projectbrief">this is a document for ExNeuron</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_f278fbcf62338d746f20818c09b59427.html">event</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">event_linux.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &quot;<a class="el" href="event_8h_source.html">event/event.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log_8h_source.html">utils/log.h</a>&quot;</code><br />
<code>#include &lt;sys/epoll.h&gt;</code><br />
<code>#include &lt;sys/timerfd.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for event_linux.c:</div>
<div class="dyncontent">
<div class="center"><img src="event__linux_8c__incl.png" border="0" usemap="#aevent__linux_8c" alt=""/></div>
<map name="aevent__linux_8c" id="aevent__linux_8c">
<area shape="rect" title=" " alt="" coords="525,5,635,32"/>
<area shape="rect" title=" " alt="" coords="5,80,80,107"/>
<area shape="rect" title=" " alt="" coords="105,80,173,107"/>
<area shape="rect" title=" " alt="" coords="482,155,569,181"/>
<area shape="rect" title=" " alt="" coords="249,80,333,107"/>
<area shape="rect" title=" " alt="" coords="388,229,471,256"/>
<area shape="rect" title=" " alt="" coords="875,229,941,256"/>
<area shape="rect" title=" " alt="" coords="545,80,615,107"/>
<area shape="rect" title=" " alt="" coords="639,80,710,107"/>
<area shape="rect" title=" " alt="" coords="735,80,809,107"/>
<area shape="rect" href="event_8h.html" title=" " alt="" coords="357,80,469,107"/>
<area shape="rect" href="log_8h.html" title=" " alt="" coords="834,80,921,107"/>
<area shape="rect" title=" " alt="" coords="997,80,1089,107"/>
<area shape="rect" title=" " alt="" coords="1113,80,1221,107"/>
<area shape="rect" title=" " alt="" coords="378,155,449,181"/>
<area shape="rect" title=" " alt="" coords="834,155,921,181"/>
<area shape="rect" href="zlog_8h.html" title=" " alt="" coords="716,155,809,181"/>
<area shape="rect" href="define_8h.html" title=" " alt="" coords="609,155,684,181"/>
<area shape="rect" title=" " alt="" coords="725,229,800,256"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneu__event__timer.html">neu_event_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneu__event__timer.html" title="neu_event_timer 结构体用于管理定时器事件的相关信息。">neu_event_timer</a> 结构体用于管理定时器事件的相关信息。  <a href="structneu__event__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneu__event__io.html">neu_event_io</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneu__event__io.html" title="neu_event_io 结构体用于管理 I/O 事件的相关信息。">neu_event_io</a> 结构体用于管理 I/O 事件的相关信息。  <a href="structneu__event__io.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__data.html">event_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a> 结构体用于存储和管理单个事件的相关信息。  <a href="structevent__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneu__events.html">neu_events</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">管理和处理事件的核心结构体。  <a href="structneu__events.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a228783873815e02b069a286af4512aba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a228783873815e02b069a286af4512aba">EVENT_SIZE</a>&#160;&#160;&#160;1400</td></tr>
<tr class="separator:a228783873815e02b069a286af4512aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac0945024ea7227a1bb4bd00d7bebeee9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structneu__event__timer.html">neu_event_timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#ac0945024ea7227a1bb4bd00d7bebeee9">neu_event_timer_t</a></td></tr>
<tr class="memdesc:ac0945024ea7227a1bb4bd00d7bebeee9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneu__event__timer.html" title="neu_event_timer 结构体用于管理定时器事件的相关信息。">neu_event_timer</a> 结构体用于管理定时器事件的相关信息。  <a href="event__linux_8c.html#ac0945024ea7227a1bb4bd00d7bebeee9">More...</a><br /></td></tr>
<tr class="separator:ac0945024ea7227a1bb4bd00d7bebeee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f41f8cb88c37798aa3b3ea7bdd3f88"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structneu__event__io.html">neu_event_io</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">neu_event_io_t</a></td></tr>
<tr class="memdesc:ad2f41f8cb88c37798aa3b3ea7bdd3f88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneu__event__io.html" title="neu_event_io 结构体用于管理 I/O 事件的相关信息。">neu_event_io</a> 结构体用于管理 I/O 事件的相关信息。  <a href="event__linux_8c.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">More...</a><br /></td></tr>
<tr class="separator:ad2f41f8cb88c37798aa3b3ea7bdd3f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62656db56e3429b55f9b382b624fe85b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structevent__data.html">event_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a62656db56e3429b55f9b382b624fe85b">event_data</a></td></tr>
<tr class="memdesc:a62656db56e3429b55f9b382b624fe85b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a> 结构体用于存储和管理单个事件的相关信息。  <a href="event__linux_8c.html#a62656db56e3429b55f9b382b624fe85b">More...</a><br /></td></tr>
<tr class="separator:a62656db56e3429b55f9b382b624fe85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d74948db7be277144ab8a06b9515bd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structneu__events.html">neu_events</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a></td></tr>
<tr class="memdesc:ad4d74948db7be277144ab8a06b9515bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">管理和处理事件的核心结构体。  <a href="event__linux_8c.html#ad4d74948db7be277144ab8a06b9515bd">More...</a><br /></td></tr>
<tr class="separator:ad4d74948db7be277144ab8a06b9515bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25fcd2e3335e715cadc7be0229ec040f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a25fcd2e3335e715cadc7be0229ec040f">get_free_event</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>)</td></tr>
<tr class="memdesc:a25fcd2e3335e715cadc7be0229ec040f"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取一个空闲的事件索引。  <a href="event__linux_8c.html#a25fcd2e3335e715cadc7be0229ec040f">More...</a><br /></td></tr>
<tr class="separator:a25fcd2e3335e715cadc7be0229ec040f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf559856a501aedd7048a5348839592"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a0cf559856a501aedd7048a5348839592">free_event</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>, int index)</td></tr>
<tr class="memdesc:a0cf559856a501aedd7048a5348839592"><td class="mdescLeft">&#160;</td><td class="mdescRight">将指定索引处的事件标记为未使用。  <a href="event__linux_8c.html#a0cf559856a501aedd7048a5348839592">More...</a><br /></td></tr>
<tr class="separator:a0cf559856a501aedd7048a5348839592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a8a4df3da87cc394c3691950d2bf51"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a45a8a4df3da87cc394c3691950d2bf51">event_loop</a> (void *arg)</td></tr>
<tr class="memdesc:a45a8a4df3da87cc394c3691950d2bf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">事件循环线程的主函数。  <a href="event__linux_8c.html#a45a8a4df3da87cc394c3691950d2bf51">More...</a><br /></td></tr>
<tr class="separator:a45a8a4df3da87cc394c3691950d2bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed56d75c185404f7c2e80f58ae89123b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#aed56d75c185404f7c2e80f58ae89123b">neu_event_new</a> (void)</td></tr>
<tr class="memdesc:aed56d75c185404f7c2e80f58ae89123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建并初始化一个新的事件管理器实例。  <a href="event__linux_8c.html#aed56d75c185404f7c2e80f58ae89123b">More...</a><br /></td></tr>
<tr class="separator:aed56d75c185404f7c2e80f58ae89123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e666b9b7b0083a2224c44d0e3e87ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a72e666b9b7b0083a2224c44d0e3e87ba">neu_event_close</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>)</td></tr>
<tr class="memdesc:a72e666b9b7b0083a2224c44d0e3e87ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">关闭并释放一个事件管理器实例。  <a href="event__linux_8c.html#a72e666b9b7b0083a2224c44d0e3e87ba">More...</a><br /></td></tr>
<tr class="separator:a72e666b9b7b0083a2224c44d0e3e87ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841fb7701198b122385290a18e7575e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="event_8h.html#ac0945024ea7227a1bb4bd00d7bebeee9">neu_event_timer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a841fb7701198b122385290a18e7575e8">neu_event_add_timer</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>, <a class="el" href="event_8h.html#a5486ebb59a5ae10a76c39d2b23752641">neu_event_timer_param_t</a> timer)</td></tr>
<tr class="memdesc:a841fb7701198b122385290a18e7575e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">向事件管理系统中添加一个新的定时器。  <a href="event__linux_8c.html#a841fb7701198b122385290a18e7575e8">More...</a><br /></td></tr>
<tr class="separator:a841fb7701198b122385290a18e7575e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ef8ce5b3f27fee5d1fa15a08247da9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a43ef8ce5b3f27fee5d1fa15a08247da9">neu_event_del_timer</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>, <a class="el" href="event_8h.html#ac0945024ea7227a1bb4bd00d7bebeee9">neu_event_timer_t</a> *timer)</td></tr>
<tr class="memdesc:a43ef8ce5b3f27fee5d1fa15a08247da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除一个定时器事件  <a href="event__linux_8c.html#a43ef8ce5b3f27fee5d1fa15a08247da9">More...</a><br /></td></tr>
<tr class="separator:a43ef8ce5b3f27fee5d1fa15a08247da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70b750f0af0f20acc85765e59291466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="event_8h.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">neu_event_io_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#ae70b750f0af0f20acc85765e59291466">neu_event_add_io</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>, <a class="el" href="event_8h.html#a0354e8de5cfe1deeb4ae61d915cb5d18">neu_event_io_param_t</a> io)</td></tr>
<tr class="memdesc:ae70b750f0af0f20acc85765e59291466"><td class="mdescLeft">&#160;</td><td class="mdescRight">向事件循环中添加一个I/O事件。  <a href="event__linux_8c.html#ae70b750f0af0f20acc85765e59291466">More...</a><br /></td></tr>
<tr class="separator:ae70b750f0af0f20acc85765e59291466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99447dadf45db972fc2d416bb3ce9f01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event__linux_8c.html#a99447dadf45db972fc2d416bb3ce9f01">neu_event_del_io</a> (<a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *<a class="el" href="modbus__tty__simulator_8c.html#a58e7644b5381f8615f8ad2e4fe3a3d9f">events</a>, <a class="el" href="event_8h.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">neu_event_io_t</a> *io)</td></tr>
<tr class="memdesc:a99447dadf45db972fc2d416bb3ce9f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">从事件循环中删除一个I/O事件。  <a href="event__linux_8c.html#a99447dadf45db972fc2d416bb3ce9f01">More...</a><br /></td></tr>
<tr class="separator:a99447dadf45db972fc2d416bb3ce9f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a228783873815e02b069a286af4512aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228783873815e02b069a286af4512aba">&#9670;&nbsp;</a></span>EVENT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_SIZE&#160;&#160;&#160;1400</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a62656db56e3429b55f9b382b624fe85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62656db56e3429b55f9b382b624fe85b">&#9670;&nbsp;</a></span>event_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structevent__data.html">event_data</a> <a class="el" href="structevent__data.html">event_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a> 结构体用于存储和管理单个事件的相关信息。 </p>
<p>创建一个通用的事件管理机制，能够统一处理不同类型的事件,并为 每种事件类型提供对应的回调函数和上下文信息</p>
<p>设计理念：</p><ul>
<li>1.灵活性与多态性模拟：通过联合体 <code>ctx</code> 存储不同类型的上 下文信息（如 I/O 或定时器），可以在同一套逻辑中处理多种事件类型。</li>
<li>2.内存管理与效率：使用联合体节省内存，避免为每种可能的事 件类型分配独立的内存空间。</li>
<li>3.模块化与抽象：将通用的信息（如回调函数、用户数据等）放在 <code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code> 中，并通过指针将其关联到具体的事件类型 （如 <a class="el" href="structneu__event__io.html" title="neu_event_io 结构体用于管理 I/O 事件的相关信息。">neu_event_io</a> 和 neu_event_timer），简化了代码结 构并提高了可维护性。</li>
<li>4.扩展性：如果将来需要添加新的事件类型（例如信号事件），只需在 <a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a> 中定义新的字段即可，而不需要修改整个事件管理系统的核心逻辑。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>为什么io的fd和timer的fd的定义位置不同？</dd></dl>
<p>-将对于 I/O 事件，fd 是公开且必要的信息，在不同的模块和函数中都可能需要直接访问 fd 来进行 I/O 操作。 将 fd 放在 <a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a> 中，方便外部代码对 I/O 事件的 fd 进行访问和操作。</p>
<p>-对于定时器事件，其内部实现细节（如 fd 的使用）应该被隐藏起来，外部代码只需要关注定时器的定时功能和触发逻辑。 将 fd 放在 neu_event_timer_t 中，能够实现定时器事件内部信息的封装，减少外部代码对定时器实现细节的依赖， 提高代码的安全性和稳定性。 </p>

</div>
</div>
<a id="ad2f41f8cb88c37798aa3b3ea7bdd3f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f41f8cb88c37798aa3b3ea7bdd3f88">&#9670;&nbsp;</a></span>neu_event_io_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structneu__event__io.html">neu_event_io</a> <a class="el" href="event_8h.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">neu_event_io_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structneu__event__io.html" title="neu_event_io 结构体用于管理 I/O 事件的相关信息。">neu_event_io</a> 结构体用于管理 I/O 事件的相关信息。 </p>
<p>该结构体包含文件描述符 (<code>fd</code>) 和关联的事件数据 (<code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code>)。</p>
<p>设计理念：</p><ul>
<li>灵活性与多态性模拟：通过联合体 <code>ctx</code>（在 <code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code> 中）存储不同类型的 上下文信息（如 I/O 或定时器），可以在同一套逻辑中处理多种事件类型。</li>
<li>内存管理与效率：使用联合体节省内存，避免为每种可能的事件类型分配独立的内存空间。</li>
<li>模块化与抽象：将通用的信息（如回调函数、用户数据等）放在 <code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code> 中，并 通过指针将其关联到具体的事件类型（如本结构体），简化了代码结构并提高了可维护性。 </li>
</ul>

</div>
</div>
<a id="ac0945024ea7227a1bb4bd00d7bebeee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0945024ea7227a1bb4bd00d7bebeee9">&#9670;&nbsp;</a></span>neu_event_timer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structneu__event__timer.html">neu_event_timer</a> <a class="el" href="event_8h.html#ac0945024ea7227a1bb4bd00d7bebeee9">neu_event_timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structneu__event__timer.html" title="neu_event_timer 结构体用于管理定时器事件的相关信息。">neu_event_timer</a> 结构体用于管理定时器事件的相关信息。 </p>
<p>NEURON IIoT System for Industry 4.0 Copyright (C) 2020-2022 EMQ Technologies Co., Ltd All rights reserved.</p>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
<p>该结构体包含文件描述符 (<code>fd</code>)、关联的事件数据 (<code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code>)、定时器值 (<code>value</code>)、定时器类型 (<code>type</code>)、互斥锁 (<code>mtx</code>) 和停止标志 (<code>stop</code>)。</p>
<p>设计理念：</p><ul>
<li>灵活性与多态性模拟：通过联合体 <code>ctx</code>（在 <code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code> 中）存储不同类型的上下文信息（如 I/O 或定时器），可以在同一套逻辑中处理多种事件类型。</li>
<li>内存管理与效率：使用联合体节省内存，避免为每种可能的事件类型分配独立的内存空间。</li>
<li>模块化与抽象：将通用的信息（如回调函数、用户数据等）放在 <code><a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a></code> 中，并通过指针将其关联到具体的事件类型（如本结构体），简化了代码结构并提高了可维护性。 </li>
</ul>

</div>
</div>
<a id="ad4d74948db7be277144ab8a06b9515bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d74948db7be277144ab8a06b9515bd">&#9670;&nbsp;</a></span>neu_events_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structneu__events.html">neu_events</a> <a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>管理和处理事件的核心结构体。 </p>
<p>该结构体封装了事件管理所需的各种资源和状态信息，使用 epoll 机制实现高效的事件多路复用， 并通过多线程方式持续监听和处理注册的事件。在多线程环境中，使用互斥锁确保对共享资源的安全访问。 </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a45a8a4df3da87cc394c3691950d2bf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a8a4df3da87cc394c3691950d2bf51">&#9670;&nbsp;</a></span>event_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* event_loop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>事件循环线程的主函数。 </p>
<p>该函数负责监听并处理通过 epoll 注册的事件（如 I/O 和定时器事件）。 它会持续运行直到 <code>events-&gt;stop</code> 被设置为 true 或发生错误。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>指向 neu_events_t 实例的指针，包含需要监听的事件信息。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>返回 NULL，因为这是一个线程入口函数。</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>此函数是一个静态函数，并且设计为在后台线程中运行。</li>
<li>使用 epoll_wait 来等待事件的发生，并根据事件类型调用相应的回调函数。</li>
<li>定时器事件处理时会检查是否需要重新设置定时器，并处理阻塞和非阻塞模式。</li>
<li>I/O 事件处理时会检查不同的事件类型（如 EPOLLIN, EPOLLRDHUP, EPOLLHUP），并调用相应的回调函数。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0cf559856a501aedd7048a5348839592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf559856a501aedd7048a5348839592">&#9670;&nbsp;</a></span>free_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void free_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将指定索引处的事件标记为未使用。 </p>
<p>该函数接收一个 neu_events_t 实例指针和一个事件索引， 并将该索引处的事件数据结构标记为未使用（use 标志设为 false）， 同时将其索引值重置为 0。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向 neu_events_t 实例的指针，包含需要操作的事件数据数组。 </td></tr>
    <tr><td class="paramname">index</td><td>需要释放的事件在 event_datas 数组中的索引。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>此函数在访问共享资源时使用了互斥锁来确保线程安全。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a25fcd2e3335e715cadc7be0229ec040f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fcd2e3335e715cadc7be0229ec040f">&#9670;&nbsp;</a></span>get_free_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int get_free_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取一个空闲的事件索引。 </p>
<p>该函数遍历 <code>events-&gt;event_datas</code> 数组，查找一个未被使用的（use 标志为 false）事件数据结构， 并将其标记为已使用（use 标志设为 true），同时设置其索引值。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向 neu_events_t 实例的指针，包含需要查找的事件数据数组。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>成功时返回找到的空闲事件的索引；如果没有找到空闲事件，则返回 -1。</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>此函数在访问共享资源时使用了互斥锁来确保线程安全。</li>
<li>EVENT_SIZE 应当是一个宏或常量，定义了事件数据数组的最大大小。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae70b750f0af0f20acc85765e59291466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70b750f0af0f20acc85765e59291466">&#9670;&nbsp;</a></span>neu_event_add_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="event_8h.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">neu_event_io_t</a>* neu_event_add_io </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#a0354e8de5cfe1deeb4ae61d915cb5d18">neu_event_io_param_t</a>&#160;</td>
          <td class="paramname"><em>io</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>向事件循环中添加一个I/O事件。 </p>
<p>Add io_event to the event.</p>
<p>此函数使用epoll接口将一个新的I/O事件添加到事件循环中。该事件将被 监控以检测可读性、错误、挂起以及由对等方关闭的连接。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向包含epoll文件描述符和事件数据数组的<code>neu_events_t</code>结构体的指针。 </td></tr>
    <tr><td class="paramname">io</td><td>包含要添加的事件的参数的<code>neu_event_io_param_t</code>结构体。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向已添加事件的<code>neu_event_io_t</code>结构体的指针。如 果添加失败，则断言失败（注意：实际生产代码应改进错误处理）。</dd></dl>
<dl class="section note"><dt>Note</dt><dd>在调用此函数之前，应确保<code>events</code>结构体已被正确初始化，并且<code>get_free_event</code>函数能 够返回有效的索引。此外，还应检查<code>io.fd</code>是否是一个有效的文件描述符。</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>io_ctx-&gt;event_data-&gt;ctx.io = events-&gt;event_datas[index].ctx.io; 操作多余 因为 io_ctx 已经指向了 events.event_datas[index].ctx_io </dd></dl>
<p>从空闲事件组中取出一个可用的 <a class="el" href="structevent__data.html" title="event_data 结构体用于存储和管理单个事件的相关信息。">event_data</a> 元素，并获取其内部存储的 I/O 事件上下文的地址 将该地址赋值给 io_ctx 指针，以便后续对该 I/O 事件上下文进行操作和初始化 这个 I/O 事件上下文将用于存储和管理新创建的 I/O 事件的相关信息</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event__linux_8c_ae70b750f0af0f20acc85765e59291466_cgraph.png" border="0" usemap="#aevent__linux_8c_ae70b750f0af0f20acc85765e59291466_cgraph" alt=""/></div>
<map name="aevent__linux_8c_ae70b750f0af0f20acc85765e59291466_cgraph" id="aevent__linux_8c_ae70b750f0af0f20acc85765e59291466_cgraph">
<area shape="rect" title="向事件循环中添加一个I/O事件。" alt="" coords="5,5,145,32"/>
<area shape="rect" href="event__linux_8c.html#a25fcd2e3335e715cadc7be0229ec040f" title="获取一个空闲的事件索引。" alt="" coords="193,5,313,32"/>
</map>
</div>

</div>
</div>
<a id="a841fb7701198b122385290a18e7575e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841fb7701198b122385290a18e7575e8">&#9670;&nbsp;</a></span>neu_event_add_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="event_8h.html#ac0945024ea7227a1bb4bd00d7bebeee9">neu_event_timer_t</a>* neu_event_add_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#a5486ebb59a5ae10a76c39d2b23752641">neu_event_timer_param_t</a>&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>向事件管理系统中添加一个新的定时器。 </p>
<p>Add a timer to the event.</p>
<p>该函数创建一个新的定时器文件描述符，设置定时器的时间间隔， 并将其注册到 epoll 实例中以便进行监控。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向 neu_events_t 实例的指针，包含需要操作的事件数据数组和 epoll 文件描述符。 </td></tr>
    <tr><td class="paramname">timer</td><td>定时器参数结构体，包含定时器的初始值、间隔时间、用户数据及回调函数等信息。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>成功时返回指向新定时器上下文的指针；失败时返回 NULL。</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>此函数在访问共享资源时使用了互斥锁来确保线程安全。</li>
<li>如果没有可用的事件槽位，函数将记录错误并终止程序。 </li>
</ul>
</dd></dl>
<p>设置定时器并启动</p>
<dl class="section note"><dt>Note</dt><dd>需在进行事件数据更新和定时器特定字段前设置， -timerfd_settime 函数的作用是启动或重新设置定时器的参数， 包括初始到期时间和重复间隔时间。一旦调用该函数，定时器就会按照 设定的参数开始计时，并且在到期时产生相应的事件。这个操作是一个 相对独立的系统调用，它不依赖于后续的事件数据和定时器上下文的设置。</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event__linux_8c_a841fb7701198b122385290a18e7575e8_cgraph.png" border="0" usemap="#aevent__linux_8c_a841fb7701198b122385290a18e7575e8_cgraph" alt=""/></div>
<map name="aevent__linux_8c_a841fb7701198b122385290a18e7575e8_cgraph" id="aevent__linux_8c_a841fb7701198b122385290a18e7575e8_cgraph">
<area shape="rect" title="向事件管理系统中添加一个新的定时器。" alt="" coords="5,5,168,32"/>
<area shape="rect" href="event__linux_8c.html#a25fcd2e3335e715cadc7be0229ec040f" title="获取一个空闲的事件索引。" alt="" coords="216,5,336,32"/>
</map>
</div>

</div>
</div>
<a id="a72e666b9b7b0083a2224c44d0e3e87ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e666b9b7b0083a2224c44d0e3e87ba">&#9670;&nbsp;</a></span>neu_event_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int neu_event_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>关闭并释放一个事件管理器实例。 </p>
<p>Close a event.</p>
<p>该函数设置停止标志，关闭 epoll 文件描述符，等待后台线程结束，销毁互斥锁，并释放分配的内存。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向要关闭的 neu_events_t 实例的指针。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>成功时返回 0。</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>此函数确保所有资源都被正确释放，包括关闭 epoll 文件描述符、等待线程结束和销毁互斥锁。</li>
<li>调用此函数后，<code>events</code> 指针将不再有效，不应再对其进行访问。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a99447dadf45db972fc2d416bb3ce9f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99447dadf45db972fc2d416bb3ce9f01">&#9670;&nbsp;</a></span>neu_event_del_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int neu_event_del_io </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad2f41f8cb88c37798aa3b3ea7bdd3f88">neu_event_io_t</a> *&#160;</td>
          <td class="paramname"><em>io</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>从事件循环中删除一个I/O事件。 </p>
<p>Delete io_event from event.</p>
<p>此函数使用epoll接口从事件循环中删除指定的I/O事件。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向包含epoll文件描述符和事件数据数组的<code>neu_events_t</code>结构体的指针。 </td></tr>
    <tr><td class="paramname">io</td><td>指向要删除的<code>neu_event_io_t</code>结构体的指针。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>总是返回0，表示函数执行成功。在实际应用中，可能需要返回错误码以处理可能的失败情况。</dd></dl>
<dl class="section note"><dt>Note</dt><dd>在调用此函数之前，应确保<code>io</code>指针是有效的，并且确实指向了一个已添加到事件循环中的I/O事件。 </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event__linux_8c_a99447dadf45db972fc2d416bb3ce9f01_cgraph.png" border="0" usemap="#aevent__linux_8c_a99447dadf45db972fc2d416bb3ce9f01_cgraph" alt=""/></div>
<map name="aevent__linux_8c_a99447dadf45db972fc2d416bb3ce9f01_cgraph" id="aevent__linux_8c_a99447dadf45db972fc2d416bb3ce9f01_cgraph">
<area shape="rect" title="从事件循环中删除一个I/O事件。" alt="" coords="5,5,141,32"/>
<area shape="rect" href="event__linux_8c.html#a0cf559856a501aedd7048a5348839592" title="将指定索引处的事件标记为未使用。" alt="" coords="189,5,281,32"/>
</map>
</div>

</div>
</div>
<a id="a43ef8ce5b3f27fee5d1fa15a08247da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ef8ce5b3f27fee5d1fa15a08247da9">&#9670;&nbsp;</a></span>neu_event_del_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int neu_event_del_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#ac0945024ea7227a1bb4bd00d7bebeee9">neu_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除一个定时器事件 </p>
<p>Remove timer from event.</p>
<p>该函数用于从一个基于 epoll 的事件处理系统中删除一个定时器事件。 它首先记录一条日志消息，然后停止定时器，并从 epoll 实例中删除定时器的文件描述符。 最后，关闭该文件描述符并释放相关资源。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>指向包含 epoll 文件描述符和其他事件处理相关信息的结构体的指针 </td></tr>
    <tr><td class="paramname">timer</td><td>指向要删除的定时器事件的结构体的指针</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>返回 0 表示成功，其他值表示失败（当前实现总是返回 0）</dd></dl>
<dl class="section note"><dt>Note</dt><dd>在调用此函数后，定时器相关的资源将被释放，定时器回调将不再执行。 </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event__linux_8c_a43ef8ce5b3f27fee5d1fa15a08247da9_cgraph.png" border="0" usemap="#aevent__linux_8c_a43ef8ce5b3f27fee5d1fa15a08247da9_cgraph" alt=""/></div>
<map name="aevent__linux_8c_a43ef8ce5b3f27fee5d1fa15a08247da9_cgraph" id="aevent__linux_8c_a43ef8ce5b3f27fee5d1fa15a08247da9_cgraph">
<area shape="rect" title="删除一个定时器事件" alt="" coords="5,5,164,32"/>
<area shape="rect" href="event__linux_8c.html#a0cf559856a501aedd7048a5348839592" title="将指定索引处的事件标记为未使用。" alt="" coords="212,5,304,32"/>
</map>
</div>

</div>
</div>
<a id="aed56d75c185404f7c2e80f58ae89123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed56d75c185404f7c2e80f58ae89123b">&#9670;&nbsp;</a></span>neu_event_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="event_8h.html#ad4d74948db7be277144ab8a06b9515bd">neu_events_t</a>* neu_event_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建并初始化一个新的事件管理器实例。 </p>
<p>Creat a new event. When an event is created, a corresponding thread is created, and both io_event and timer_event in this event are scheduled for processing in this thread.</p>
<p>该函数分配内存并初始化一个 neu_events_t 结构体实例，创建一个 epoll 文件描述符， 并启动一个后台线程来处理事件循环。</p>
<dl class="section return"><dt>Returns</dt><dd>返回一个指向新创建的 neu_events_t 实例的指针。 如果内存分配失败或 epoll 文件描述符创建失败，则程序将终止（通过 assert）。</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>此函数使用 calloc 分配内存，并确保所有字段都被初始化为零。</li>
<li>epoll_create(1) 用于创建一个新的 epoll 实例。参数 '1' 是提示内核分配的大小，但实际大小是动态调整的。</li>
<li>该函数还初始化了一个互斥锁和一个后台线程，用于处理事件循环。 </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event__linux_8c_aed56d75c185404f7c2e80f58ae89123b_cgraph.png" border="0" usemap="#aevent__linux_8c_aed56d75c185404f7c2e80f58ae89123b_cgraph" alt=""/></div>
<map name="aevent__linux_8c_aed56d75c185404f7c2e80f58ae89123b_cgraph" id="aevent__linux_8c_aed56d75c185404f7c2e80f58ae89123b_cgraph">
<area shape="rect" title="创建并初始化一个新的事件管理器实例。" alt="" coords="5,5,129,32"/>
<area shape="rect" href="event__linux_8c.html#a45a8a4df3da87cc394c3691950d2bf51" title="事件循环线程的主函数。" alt="" coords="177,5,272,32"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
